/// ! This file is generated from ../../../codegen/Scene/NSceneKinematicVis.xtoml !
/// ! Do not edit this file manually !

class D_NSceneKinematicVis_SMgr : RawBufferElem {
	D_NSceneKinematicVis_SMgr(RawBufferElem@ el) {
		if (el.ElSize != 0x78) throw("invalid size for D_NSceneKinematicVis_SMgr");
		super(el.Ptr, el.ElSize);
	}
	D_NSceneKinematicVis_SMgr(uint64 ptr) {
		super(ptr, 0x78);
	}

	// This is exposed normally, but has no properties
	D_NSceneKinematicVis_SConstraints@ get_Constraints() { return D_NSceneKinematicVis_SConstraints(this.GetBuffer(0x8, 0x58, false)); }
}

class D_NSceneKinematicVis_SConstraints : RawBuffer {
	D_NSceneKinematicVis_SConstraints(RawBuffer@ buf) {
		super(buf.Ptr, buf.ElSize, buf.StructBehindPtr);
	}
	D_NSceneKinematicVis_SConstraint@ GetSConstraint(uint i) {
		return D_NSceneKinematicVis_SConstraint(this[i]);
	}
}

class D_NSceneKinematicVis_SConstraint : RawBufferElem {
	D_NSceneKinematicVis_SConstraint(RawBufferElem@ el) {
		if (el.ElSize != 0x58) throw("invalid size for D_NSceneKinematicVis_SConstraint");
		super(el.Ptr, el.ElSize);
	}
	D_NSceneKinematicVis_SConstraint(uint64 ptr) {
		super(ptr, 0x58);
	}

	// 0x0: pointer to NSceneKinematicVis_SSharedSignal
	// -> 0x0 pointer to NPlugDyna_SKinematicConstraint
	// > 0x8 quaternion stuff or maybe matrix
	D_NSceneKinematicVis_SSharedSignal@ get_Signal() { auto _ptr = this.GetUint64(0x0); if (_ptr == 0) return null; return D_NSceneKinematicVis_SSharedSignal(_ptr); }
	// 0x8: 0, -1,
	// 0x10: 0, 0
	// 0x18: class ID: SHmsInstDyna, then 0x1 byte which is size of SHmsInstDyna (=7)
	uint32 get_hms_class_id() { return (this.GetUint32(0x18)); }
	// 1 byte: https://xertrov.github.io/op-tm-api-docs/next/SHmsInstDyna
	uint8 get_hms_instance() { return (this.GetUint8(0x1C)); }
	uint32 get_some_id() { return (this.GetUint32(0x20)); }
	// 
	iso4 get_Loc() { return (this.GetIso4(0x28)); }
	void set_Loc(iso4 value) { this.SetIso4(0x28, value); }
	// 0x4C: base position of the visible mesh (does not change collisions)
	vec3 get_Pos() { return (this.GetVec3(0x4C)); }
	void set_Pos(vec3 value) { this.SetVec3(0x4C, value); }
	float get_PosX() { return (this.GetFloat(0x4C)); }
	void set_PosX(float value) { this.SetFloat(0x4C, value); }
	float get_PosY() { return (this.GetFloat(0x50)); }
	void set_PosY(float value) { this.SetFloat(0x50, value); }
	float get_PosZ() { return (this.GetFloat(0x54)); }
	void set_PosZ(float value) { this.SetFloat(0x54, value); }
}


class D_NSceneKinematicVis_SSharedSignal : RawBufferElem {
	D_NSceneKinematicVis_SSharedSignal(RawBufferElem@ el) {
		if (el.ElSize != 0x40) throw("invalid size for D_NSceneKinematicVis_SSharedSignal");
		super(el.Ptr, el.ElSize);
	}
	D_NSceneKinematicVis_SSharedSignal(uint64 ptr) {
		super(ptr, 0x40);
	}

	NPlugDyna_SKinematicConstraint@ get_Model() { return cast<NPlugDyna_SKinematicConstraint>(this.GetNod(0x0)); }
	uint64 get_ModelPtr() { return (this.GetUint64(0x0)); }
	float get_Phase() { return (this.GetFloat(0x8)); }
	void set_Phase(float value) { this.SetFloat(0x8, value); }
	// PosY or translation offset?
	vec3 get_PosOff() { return (this.GetVec3(0x30)); }
	void set_PosOff(vec3 value) { this.SetVec3(0x30, value); }
	float get_PosX() { return (this.GetFloat(0x30)); }
	void set_PosX(float value) { this.SetFloat(0x30, value); }
	float get_PosY() { return (this.GetFloat(0x34)); }
	void set_PosY(float value) { this.SetFloat(0x34, value); }
	float get_PosZ() { return (this.GetFloat(0x38)); }
	void set_PosZ(float value) { this.SetFloat(0x38, value); }
	uint get_cRef() { return (this.GetUint32(0x3c)); }
	void set_cRef(uint value) { this.SetUint32(0x3c, value); }
}


